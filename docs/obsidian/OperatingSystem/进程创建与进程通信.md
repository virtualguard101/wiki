---
date: 2025-12-05 17:26:34
title: 进程创建与进程通信
permalink:
publish: true
tags:
  - 操作系统
---

# 进程创建与进程通信

## 通过fork系统调用创建进程

在[Linux基础、杂项](../Tools/linux/Linux基础、杂项.md)环境下，可通过`fork()`系统调用创建新的进程：

```c
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    pid_t childpid = fork();
    childpid = fork();

    if (childpid == 0) {
        printf("CHILD: I am child process, the pid is %d\n", getpid());
        printf("CHILD: my parent's pid is %d\n", getppid());
        exit(0);
    }
    if (childpid > 0) {
        printf("PARENT: I am parent process, the pid is %d\n", getpid());
        printf("PARENT: My child's pid is %d\n", childpid);
        sleep(1);
        exit(0);
    }
}
```

调用 fork() 会复制当前进程，产生一个子进程。父子进程几乎完全相同（代码、数据、堆栈等），区别在于下面提到的返回值。

`fork()`调用具有三种类型的返回值:

- 如果子进程创建失败，则返回`-1`

- 若返回值为`0`，则表示当前进程是子进程

- 若返回值大于`0`，则表示当前进程是父进程，返回值为子进程的PID

!!! tip "Why and How"
    操作系统需要多进程并发执行。fork 让一个程序可以创建多个执行实例，实现并行处理、服务多客户端、或分离任务。

    调用 fork() 后，根据返回值判断是父进程还是子进程，然后分别执行不同逻辑。常见模式是父进程等待子进程完成，子进程执行具体任务。

在上面的`C`程序中:

1. **第一次fork**（`pid_t childpid = fork();`）

   - 创建第一个子进程

   - 此时有两个进程：原始父进程和第一个子进程

2. **第二次fork**（`childpid = fork();`这一行）

   - ⚠️ **重要**：两个进程都会执行这行代码

   - 原始父进程fork出第二个子进程

   - 第一个子进程也会fork出它的子进程

   - 最终会有4个进程！

3. **子进程处理**（第10-14行）

   - 打印自己的PID和父进程的PPID

   - 退出

4. **父进程处理**（第15-20行）

   - 打印自己的PID和子进程的PID

   - 睡眠1秒后退出

最终创建的进程树结构如下:

```
原始进程 (P1)
├── 子进程1 (C1)
│   └── 子进程1的子进程 (C1-1)
└── 子进程2 (C2)
```

## 父子进程协作作业

前面提到了为什么需要`fork()`调用——操作系统需要多进程并发执行，父子进程协作作业则是实现这一目标的一个重要方式。
