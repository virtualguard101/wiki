# 多元线性回归模型

> [有监督的机器学习：回归与分类 | coursera](https://www.coursera.org/learn/machine-learning)

## 特征向量

在现实生活中，只靠一个指标评判一个事物显然是不合理的，因此我们需要引入多元回归来使得模型功能更强大、预测更准确。

以我们在一元线性回归模型中提到的房价预测模型为例，现在我们在其仅有面积这一个特征变量的基础上为其添加多个特征变量:

| 数据组序号 $i$ | 面积 $x_1(feet^2)$ | 主卧数 $x_2$ | 楼层数 $x_3$ | 房龄 $x_4(year)$ | **价格** $(1000\$)$ |
|:-------------:|:------------------:|:-----------:|:------------:|:---------------:|:---------------:|
|       1       |        2104        |      5      |       1      |       45        |       460       |
|       2       |        1416        |      3      |       2      |       40        |       232       |
|       3       |        1534        |      3      |       2      |       30        |       315       |
|   $\cdots$    |      $\cdots$      |   $\cdots$  |    $\cdots$  |     $\cdots$    |     $\cdots$    |

在这里，

- $x_j$ 表示第 $j$ 个特征

- ==$\overrightarrow{x}^{(i)}$ 表示第 $i$ 组训练数据==

- ==$x_{j}^{(i)}$ 表示第 $i$ 组训练数据中的第 $j$ 个特征变量==

- $n$ 表示单组训练数据中含有的特征变量数

其中，单组训练数据我们可以用一个 **$n$ 维向量**表示与存储，称为**特征向量（*Feature Vector*）**，记作:

$$
\overrightarrow{x}^{(i)} = [x_{1}^{(i)}, x_{2}^{(i)}, \cdots, x_{n}^{(i)}]
$$

以上面的数据案例为例，第 $1$ 组数据就可以用下面这个 $4$ 维向量存储:

$$
\overrightarrow{x}^{(1)} = [2104, 5, 1, 45]
$$

## 多元线性回归方程

由于我们现在拥有多个特征值，那么就应该考虑如何将这些特征值与模型函数的参数对应起来从而组成一个方程方便我们实现。

观察一元线性回归模型的方程:

$$
f_{w, b}(x^{(i)}) = wx^{(i)} + b
$$

结合上面特征向量的概念我们不难发现，这里的特征值 $x^{(i)}$ 只有数据组标号 $i$，而没有特征标号 $j$——因为一元模型只有一个特征值。

现在我们引入了多个特征值，应该怎么将其建模成一个数学方程呢？首先我们应该想到，既然我们有多个特征变量，那么我们为所有的变量都分配一个参数 $w_j$ 不就行了吗？于是方程便成了这样:

$$
f_{w_1, w_2, \cdots, w_n, b}(x_{1}^{(i)}, x_{2}^{(i)}, \cdots, x_{n}^{(i)}) = w_{1}x_{1}^{(i)} + w_{2}x_{2}^{(i)} + \cdots + w_{n}x_{n}^{(i)}+ b
$$

上面面我们还提到了，针对单组数据我们可以通过一个 **$n$ 维向量**来表示与存储，又因为模型参数与特征值是一一对应的，因此这 $n$ 个参数 $w$ 也可以写成一个维度与特征向量相同的向量。==于是方程就可以写成**向量点积**的形式==:

$$
f_{\overrightarrow{w}, b}(\overrightarrow{x}^{(i)}) = \overrightarrow{w} \cdot \overrightarrow{x}^{(i)} + b
$$

其中 $\overrightarrow{w}$ 与 $\overrightarrow{x}^{(i)}$ **均为** $n$ 维向量。

## 矢量化

不使用矢量化需要将参数乘上特征变量逐个相加:

$$
\begin{align}
    f_{\overrightarrow{w}, b}(\overrightarrow{x}) & = w_{1}x_{1} + w_{2}x_{2} + \cdots + w_{n}x_{n} + b \\
    & = \sum_{j=1}^{n} w_{j}x_{j} + b
\end{align}
$$

```py
f = w[0] * x[0] +
    w[1] * x[1] +
    ...         + b
```

或使用 `for` 循环:

```py
for j in range(n):
    f = w[j] + x[j]
f = f + b
```

使用矢量化则可以直接调用 `NumPy`中 `array` 的 `dot()` 方法，即向量点积:

$$
f_{\overrightarrow{w}, b}(\overrightarrow{x}) = \overrightarrow{w} \cdot \overrightarrow{x} + b
$$

```py
f = np.dot(w, x) + b
```
