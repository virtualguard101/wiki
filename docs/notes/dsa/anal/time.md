# 算法时间复杂度

>[大话数据结构【溢彩加强版】](https://zh.z-library.sk/book/21866019/61284b/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%A2%E5%BD%A9%E5%8A%A0%E5%BC%BA%E7%89%88.html){target="_blank"}
>
>[时间复杂度 | Hello 算法](https://www.hello-algo.com/chapter_computational_complexity/time_complexity/){target="_blank"}


在评估一个算法的效率时，我们的第一反应通常是这个算法处理一定数量的任务需要多少时间；然而，准确计算出一个程序在不同设备上的运行时间是复杂且不现实的，因此我们需要一个通用的方法来衡量算法的运行效率。

## 定义

时间复杂度量化分析的不是算法的运行时间，而是 ==算法运行时长随着其处理的数据量的增加而增长的**趋势**==。

### 函数渐近上界与算法的渐进时间复杂度

==算法时间复杂度分析本质上是计算算法在处理特定问题规模（这个规模我们通常会假定其无穷大）所需“操作数量”的**函数的渐进上界**==，它具有明确的数学定义：

设算法的操作数量是一个关于输入数据大小 $n$ 的函数，记作 $T(n)$，则有定义

!!! important "函数渐近上界"
    若存在正实数 $c$ 和 实数 $n_0$，使得对于对于所有的 $n > n_0$，均有 $T(n) < c \cdot f(n)$，则可认为 $f(n)$ 给出了 $T(n)$ 的一个渐进上界，记作：
    
    $$
    T(n) = O(f(n))
    $$

在数学与计算机科学中，常使用形似 $O(f(n))$ 的形式来表示一个算法的时间复杂度，称为 ==大 $O$ 记法==，是一个**渐进上界**；其中 $f(n)$ 是关于问题规模 $n$ 的某个函数，==通常是一个系数为 $1$ 的**单项式**==。

### 推算 $O(f(n))$

一般分两步可推算出一个算法的时间复杂度：

1. 构造操作数函数 $T(n)$

    其中在构造时可以**忽略操作函数项的系数以及常数项**，例如有以下程序：

    ```py
    def func(n: int) -> None:
      a = 1     # +1
      a = n + 1 # +1
      
      for i in range(5*n + 1):
        # +n
        print(n)
      
      for i in range(2 * n):
        for j in range(n + 1):
          +n*n
          print(n)
    ```

    若完全统计上述程序的操作数，则有：

    $$
    \begin{aligned}
      T(n) & = 2 + (5n + 1) + 2n(n + 1) \newline
      & = 2n^2 + 7n + 3
    \end{aligned}
   $$

