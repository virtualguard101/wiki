---
date: 2025-10-28 16:42:40
title: 同步与互斥
permalink: 
publish: true
---

# 同步与互斥

> [进程与线程](2-process.md)

## 部分概念

### 操作系统中的资源类型

#### 可重用性资源

顾名思义，就是可供用户重复多次使用的资源。

- 一次只能分配给一个进程，不允许多个进程共享

- 进程在使用该资源时，需要先申请并获得该资源，使用完毕后释放该资源

- 单元数目相对固定，进程在运行期间既不能创建也不能删除

#### 可消耗性资源

临时性资源，由进程动态创建和消耗（进程通信间的消息、信号量等）。

- 单元数目不固定，可以按需要随时创建，使用完毕后自动释放

#### 可抢占资源

某进程在获得这类资源后，该进程可以再被其他进程或系统抢占（如处理机、主存等）。

#### 不可抢占资源

当系统把这类资源分配给某进程后，就不能再强行收回，只能在进程用完后自行释放（如磁带、打印机等）。

#### ⭐临界资源

**临界资源（*Critical Resource*）**是指在操作系统中，多个进程需要通过**互斥**访问方法访问的、**不可抢占**的资源。

### 访问临界资源

每个进程中访问临界资源的那段代码称为**临界区**。临界资源的访问大致可分为四个步骤:

1. 进入区: 检查是否可以进入临界区

2. 临界区: 访问临界资源的代码，也成为**临界段**

3. 退出区: 释放临界资源，将正在访问临界区的标志清除

4. 剩余区: 代码的其余部分

```cpp
while (true) {
  entry section;     // 进入区
  critical section;  // 临界区
  exit section;      // 退出区
  remainder section; // 剩余区
}
```

### 同步

**同步（*Synchronization*）**也称为**直接约束关系**，是指为完成某种任务而建立的两个或多个进程，因为需要协调它们的工作次序并等待它们相互通信、等待消息等所产生的制约关系。

同步的本质是**资源访问的排队机制**，源于进程之间的相互合作。

- 核心要素

    - 共享资源：收银机（临界资源）

    - 访问控制：排队规则（同步原语）

    - 互斥访问：同一时刻只有一个人能用收银机

        !!! tip
            同步需要基于[互斥](#互斥)实现。

    - 顺序保证：先到先得（happens-before）

!!! example
    - 没有同步：
        ```
        10:00 - 你：我要一杯珍珠奶茶
        10:00 - 小明：我要一杯柠檬茶  
        10:00 - 小红：我要一杯抹茶拿铁
        店员：？？？你们同时说话我听不清！
        ```
        结果：订单混乱，可能做错或漏做（不可重现）

    - 有同步：
        ```
        10:00 - 你：我要一杯珍珠奶茶（获得"收银机锁"）
        10:01 - 店员：好的，15元（你释放锁）
        10:01 - 小明：我要一杯柠檬茶（获得"收银机锁"）
        10:02 - 店员：好的，12元（小明释放锁）
        10:02 - 小红：我要一杯抹茶拿铁（获得"收银机锁"）
        ```
        结果：每个人都能清楚下单，不会混乱

    ```cpp
    // 收银机 = 共享变量
    int cash_register = 0;  // 收银机状态
    std::mutex line_mutex;  // 排队规则

    void buy_drink(string customer, string drink) {
        std::lock_guard<std::mutex> lock(line_mutex);  // 排队等待
        
        // 临界区：使用收银机
        cout << customer << "In Processing" << drink << endl;
        cash_register++;  // 更新收银机状态
        
        // 自动释放锁，下一个人可以排队
    }
    ```

### 互斥

**互斥（Mutex）**是另外一个同步机制，也称为**间接约束关系**，用于确保同一时间只有一个线程能够访问共享资源。

互斥用于多线程环境下的竞态条件问题，通过"锁定-访问-解锁"的模式保证临界区代码的原子性执行。

!!! info "竞态条件问题"
    **竞态条件（*Race Condition*）**问题是指在多线程环境下，由于多个线程同时访问共享资源，导致程序运行结果不确定的问题。

    ```py
    # 危险的代码示例
    counter = 0

    def increment():
        global counter
        temp = counter    # 读取当前值
        temp += 1         # 计算新值
        counter = temp    # 写入新值

    # 如果两个线程同时执行，可能出现：
    # 线程A: 读取counter=0，计算temp=1
    # 线程B: 读取counter=0，计算temp=1  
    # 线程A: 写入counter=1
    # 线程B: 写入counter=1
    # 结果：期望counter=2，实际counter=1 ❌
    ```

### 同步与互斥的区别

!!! abstract

    |  | 同步 (**Synchronization**) | 互斥 (**Mutex**) |
    | :-: | :-: | :-: |
    | 主要目的 | 协调顺序执行 | 防止竞态条件 |
    | 排队性质 | 主动协调 | 被动响应 |
    | 等待条件 | 特定条件满足 | 资源（锁）释放 |
    | 通知机制 | 手动（信号量等） | 自动（锁释放） |
    | 复杂度 | 相对复杂 | 相对简单 |

二者的本质都可以抽象成一个**资源访问的排队机制**。但在解决的核心问题与解决方式上有所不同：

- 同步

    - 核心问题: ==协调多个进程/线程的执行顺序==，保证它们按照一定的规则有序执行

    - 解决方式是通过**同步原语**（如信号量、条件变量等），==让线程按照特定顺序或条件执行==

    ```py
    # 同步：协调生产者和消费者的执行顺序
    import threading

    buffer = []
    mutex = threading.Lock()
    not_empty = threading.Condition(mutex)
    not_full = threading.Condition(mutex)

    def producer():
        with not_full:  # 同步：等待缓冲区有空间
            while len(buffer) >= 10:
                not_full.wait()
            buffer.append("item")
            not_empty.notify()  # 通知消费者

    def consumer():
        with not_empty:  # 同步：等待缓冲区有数据
            while len(buffer) == 0:
                not_empty.wait()
            item = buffer.pop()
        not_full.notify()  # 通知生产者
    ```

- 互斥

    - 核心问题: ==防止多个线程同时访问共享资源==

    - 解决方式: 通过互斥锁（Mutex），==确保同一时间只有一个线程访问共享资源==

    ```py
    # 互斥：确保只有一个线程能修改共享变量
    counter = 0
    mutex = threading.Lock()

    def increment():
        with mutex:  # 互斥：一次只能有一个线程
            global counter
            counter += 1
    ```

- 前者的目的是**协调执行顺序，实现逻辑**，后者则是**避免冲突，确保安全**


## 临界区互斥访问的实现方法

实现临界区互斥访问必须要满足以下四个原则：

1. **空闲让进**: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区

2. **忙则等待**: 当临界区被占用时，其他试图进入临界区的进程必须等待

3. **有限等待**: 对请求进入临界区的进程，应保证能在有限时间内进入临界区

4. **让权等待**: 当进程不能进入临界区时，应立即释放处理器，防止进程忙等待
   
这里注意第四点并非必须遵守，但原则上应该遵循以提高CPU利用率。

### 软件实现

#### 单标志法

!!! abstract

    | 评价标准 | 单标志法 | 说明 |
    | :-: | :-: | :-: |
    | 空闲让进 | ❌ | 空闲时其他进程可能无法进入 |
    | 忙则等待 | ✅ | 当临界区被占用时，其他试图进入临界区的进程必须等待 |
    | 有限等待 | ❌ | 因违反"空闲让进"原则，无法保证等待时间有限 |
    | 让权等待 | ❌ | 使用忙等待，浪费CPU资源 |

- 使用一个全局标志变量 `turn`，表示当前允许进入临界区的进程编号

- 每个进程在进入临界区前检查 `turn` 是否等于自己的进程号

- 只有 `turn` 等于自己进程号的进程才能进入临界区

```cpp
// 全局变量
int turn = 0;  // 0表示进程0可以进入，1表示进程1可以进入

// 进程0的代码
void process0() {
    while (true) {
        // 进入区：检查是否可以进入
        while (turn != 0) {
            // 忙等待，直到轮到自己
        }
        
        // 临界区
        critical_section();
        
        // 退出区：让给另一个进程
        turn = 1;
        
        // 剩余区
        remainder_section();
    }
}

// 进程1的代码
void process1() {
    while (true) {
        // 进入区：检查是否可以进入
        while (turn != 1) {
            // 忙等待，直到轮到自己
        }
        
        // 临界区
        critical_section();
        
        // 退出区：让给另一个进程
        turn = 0;
        
        // 剩余区
        remainder_section();
    }
}
```

该算法实现简单且可以实现每次只用一个进程进入临界区，但两个进程必须**交替**进入临界区。

- **违反"空闲让进"原则**: 若某个进程不再进入临界区，则另一个进程则永远无法进入临界区

- **违反"有限等待"原则**: 进程必须严格按照交替顺序进入，无法保证公平性

#### 双标志先检查法

!!! abstract
    | 评价标准 | 双标志先检查法 | 说明 |
    | :-: | :-: | :-: |
    | 空闲让进 | ✅ | 空闲时其他进程可以进入 |
    | 忙则等待 | ❌ | 进程可能同时进入临界区 |
    | 有限等待 | ❌ | 可能形成死锁 |
    | 让权等待 | ❌ | 使用忙等待，浪费CPU资源 |

- 为每个进程设置一个布尔标志位 `flag[i]`，表示进程i是否想进入临界区

- 进程在进入临界区前，**先检查**其他进程的标志位 `flag[j]`，**后设置**自己的标志位 `flag[i] = true`

```cpp
// 全局变量
bool flag[2] = {false, false};  // 标志数组，表示进程是否想进入临界区

// 进程0的代码
void process0() {
    while (true) {
        // 进入区：先检查其他进程是否想进入
        while (flag[1]) {
            // 如果进程1想进入，等待
        }
        
        // 然后才设置自己的标志
        flag[0] = true;
        
        // 临界区
        critical_section();
        
        // 退出区：清除自己的标志
        flag[0] = false;
        
        // 剩余区
        remainder_section();
    }
}

// 进程1的代码
void process1() {
    while (true) {
        // 进入区：先检查其他进程是否想进入
        while (flag[0]) {
            // 如果进程0想进入，等待
        }
        
        // 然后才设置自己的标志
        flag[1] = true;
        
        // 临界区
        critical_section();
        
        // 退出区：清除自己的标志
        flag[1] = false;
        
        // 剩余区
        remainder_section();
    }
}
```

该算法虽然先检查再设置，但仍然存在严重问题：

- **违反"忙则等待"原则**: 在设置与检查之间的时间节点可能发生进程切换，导致两个进程都检查通过，最终使两个进程同时进入临界区

    原因在于*检查与赋值*两个操作不是一气呵成的，给了**进程切换**的机会。
    
    ```cpp
    // 危险的执行序列
    // 时间点1：进程0检查 flag[1] = false（此时进程1还未设置flag[1]）
    // 时间点2：进程1检查 flag[0] = false（此时进程0还未设置flag[0]）
    // 时间点3：进程0设置 flag[0] = true，进入临界区
    // 时间点4：进程1设置 flag[1] = true，进入临界区
    // 结果：两个进程同时进入临界区！❌
    
    void process0() {
        while (flag[1]) {      // 时间点1：检查时flag[1]还是false
            // 不等待，继续执行
        }
        flag[0] = true;        // 时间点3
        critical_section();
    }
    
    void process1() {
        while (flag[0]) {      // 时间点2：检查时flag[0]还是false
            // 不等待，继续执行
        }
        flag[1] = true;        // 时间点4
        critical_section();
    }
    ```


#### 双标志后检查法

!!! abstract
    | 评价标准 | 双标志后检查法 | 说明 |
    | :-: | :-: | :-: |
    | 空闲让进 | ❌ | 可能两个进程同时检查都无法进入 |
    | 忙则等待 | ✅ | 解决了先检查法的竞态问题 |
    | 有限等待 | ❌ | 因违反"空闲让进"原则，无法保证等待时间有限 |
    | 让权等待 | ❌ | 使用忙等待，浪费CPU资源 |

- 与先检查法相反，进程**先设置**自己的标志位 `flag[i] = true`，**后检查**其他进程的标志位 `flag[j]`

- 只有当其他进程都不想进入临界区时，当前进程才能进入临界区

```cpp
// 全局变量
bool flag[2] = {false, false};  // 标志数组，表示进程是否想进入临界区

// 进程0的代码
void process0() {
    while (true) {
        // 进入区：先设置自己的标志
        flag[0] = true;
        
        // 检查其他进程是否也想进入
        while (flag[1]) {
            // 如果进程1也想进入，等待
        }
        
        // 临界区
        critical_section();
        
        // 退出区：清除自己的标志
        flag[0] = false;
        
        // 剩余区
        remainder_section();
    }
}

// 进程1的代码
void process1() {
    while (true) {
        // 进入区：先设置自己的标志
        flag[1] = true;
        
        // 检查其他进程是否也想进入
        while (flag[0]) {
            // 如果进程0也想进入，等待
        }
        
        // 临界区
        critical_section();
        
        // 退出区：清除自己的标志
        flag[1] = false;
        
        // 剩余区
        remainder_section();
    }
}
```

- **违反"忙则等待"原则**: 尝试通过调整操作顺序来解决先检查法的问题，但可能两个进程在检查时双方都已经设置了自己的标志表明想进入临界区，最终导致两个进程都陷入等待


    ```cpp
    // 危险的执行序列
    // 时间点1：进程0设置 flag[0] = true
    // 时间点2：进程1设置 flag[1] = true  
    // 时间点3：进程0检查 flag[1] = true，发现进程1想进入临界区，等待
    // 时间点4：进程1检查 flag[0] = true，发现进程0也想进入临界区，等待
    // 结果：两个进程都认为对方想进入临界区，结果谁也进不了！❌

    void process0() {
        flag[0] = true;        // 时间点1
        while (flag[1]) {      // 时间点3，检查发现进程1想进入临界区，等待
            // 等待
        }
        critical_section();
    }

    void process1() {
        flag[1] = true;        // 时间点2
        while (flag[0]) {      // 时间点4，检查发现进程0也想进入临界区，也陷入等待
            // 等待
        }
        critical_section();
    }
    ```

#### Peterson 算法

### 硬件实现

#### 中断屏蔽

#### TS 指令

#### Swap 指令
