---
date: 2025-11-10 11:06:15
title: 虚拟内存管理
permalink: 
publish: true
---

# 虚拟内存管理

## 传统内存管理方式的特征

- 一次性：作业中的所有信息都被装入内存后才能开始运行

- 驻留性：作业一旦驻留内存后，就会一直驻留在内存中直到作业运行结束，其任何部分都不会被换出

显然，这样的管理方式会造成大量实际并没用或暂时没用的程序或数据驻留内存，造成大量内存空间浪费。

## 局部性原理

>[局部性原理 | 腾讯云开发者社区](https://cloud.tencent.com/developer/article/1777697)

!!! quote
    广义上来看，地球、生命、万事万物都是局部性的产物，因为这些都是宇宙中熵分布布局、局部的熵低导致的，如果宇宙中处处熵一致，有的只有一片混沌。

**局部性**是一个常见的计算机术语，是指处理器在访问某些数据时短时间内存在重复访问，某些数据或者位置访问的概率极大，大多数时间只访问局部的数据。**其本质其实就是概率的不均等**。

局部性可分为两种类型:

- **时间局部性（*Temporal locality*）**: 如果某个信息这次被访问，那它有可能在不久的未来被多次访问。时间局部性是空间局部性访问地址一样时的一种特殊情况。

- **空间局部性（*Spatial locality*）**: 如果某个信息这次被访问，那它附近的信息也有可能被访问。从程序执行的角度来看，大部分情况下代码都是顺序执行，数据也是顺序访问的。

其他类型的局部性大多都可以看作是这两者的特例。

### 页面置换算法的局部性原理[^1]

- 从时间局部性来看，程序中的某条指令一旦被执行，不久之后很可能再次被执行，数据访问同理。原因是程序中存在大量的**循环操作**。

- 从空间局部性来看，一旦程序访问了某个存储单元，不久之后，其附近的存储单元也将被访问，即**程序在一段时间内所访问的地址，可能集中在一定的范围之内**。这是因为程序顺序执行时，指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

## 虚拟内存概述

- 基于[局部性原理](#局部性原理)，在程序装入时，仅需将程序当前需要用到的少数页面（或段）装入内存，便可让程序开始执行。

- 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序，这个过程就是**请求调页（段）**。

- 当内存空间不足时，由操作系统负责将内存中暂时用不到的信息换出到外存，这个过程就是**页面（段）置换**。

基于上面三个实现逻辑，我们就得到了一个看上去比实际物理内存大得多的存储器，称为**虚拟存储器**。

??? tip "浏览器的省内存模式"
    上面的描述可以结合现代浏览器的“省内存模式”进行理解:

    ![](assets/3-virtual-mem/browser_exmaple.png)

    一个运行中的浏览器标签只把活跃页面留在RAM，后台标签数据暂存在磁盘；你切回时操作系统再把缺页内容调入。

### 虚拟内存的特性

- 多次性: 无需**一次性**将程序的所有页面都装入内存，而是允许在程序执行过程中分多次将页面调入内存。

- **对换性**: 作业在运行时无需一直驻留在内存中，而是允许在运行过程中将某些页面换出到外存对换区，以便腾出空间来装入其他页面。

- **虚拟性**: 从逻辑上扩充了内存的容量，使用户所看到的内存容量远大于实际的物理内存容量。这是虚拟内存最显著且重要的特征。

### 虚拟内存的实现

虚拟内存的实现一般有如下三种方式:

- 请求分页存储管理

- 请求分段存储管理

- 请求段页式存储管理

与内存管理方式中的三个[现代内存管理模型](3-memory-management.md#现代内存管理方式)一一对应，但都为支持虚拟存储器而增加了一些新的机制。

同时，无论使用哪一种虚拟内存实现方式，都需要硬件支持:

- 一定容量的内存和外存

- 页表机制（或段表机制）

- **中断机构**

- 地址变换机构

## 请求分页存储管理

>[请求分页存储管理方式 | 知乎@该用户已注册](https://zhuanlan.zhihu.com/p/530601684)

### 页表机制

相比较[基本分页系统](3-memory-management.md#基本分页存储管理)，在请求分页中，为实现**请求调页功能**，操作系统需要知道每个页面是否已经调入内存，如果已经调入，则需要知道该页面在内存中的位置；如果未调入，则需要知道该页面在外存中的位置。

同时，为了实现**页面置换功能**，操作系统需要根据某种指标来决定将哪个页面换出内存，对于要换出的页面，还需要知道其是否被修改过，以决定是否需要写回外存。

针对上述两个需求，请求页表项添加了四个字段:

- **状态位 $P$**: 用于表示页面是否已经调入内存，供程序访问时参考。

- **访问字段 $A$**: 用于记录页面一段时间内被访问的次数，或本页已有多长时间未被访问，供置换算法选择换出页面时参考。

- **修改位 $M$**: 用于表示页面是否被修改过，以决定换出时是否需要写回外存。

- **外存地址**: 用于记录页面在外存中的位置，通常是物理块号，供调入页面时使用。

| 页号 | 物理块号 | 状态位 $P$ | 访问字段 $A$ | 修改位 $M$ | 外存地址 |
|:---:|:---:|:---:|:---:|:---:|:---:|

### 缺页中断机构

在请求分页系统中，当要访问的页面不在内存时，便会产生一次缺页中断，请求操作系统的缺页中断处理程序处理。此时缺页的进程会进入[阻塞状态](2-process.md#三种基本状态)，放入阻塞队列；调页完成后，进程会从阻塞状态变为[就绪状态](2-process.md#三种基本状态)，并插入就绪队列等待调度。

缺页中段与一般中断有两个明显区别:

- 在指令执行期间而非一条指令执行完后产生和处理中断信号，属于[内部异常](1-os-run-env.md#中断与异常)

- 一条指令在执行期间，可能产生多次缺页中断

### 地址变换机构

![请求调页的地址变换过程](assets/3-virtual-mem/request_page.jpg)

在基本分页系统的基础上增加了**中断产生/处理**与**页面置换**，流程描述如下:

1. 先检索快表，若命中，则从对应表项取出该页的物理块号，并修改页表项中的访问位 $P$，以供置换算法换出页面时参考。对于写指令，还需将修改位 $M$ 置 1。

2. 若快表检索未命中，则需要从页表中找到该页的物理块号，并将其放入快表中。

3. 若在页表中也未找到，则需要进行**缺页中断处理**，请求系统将该页从外存换入内存，更新页表、快表，并获得物理块号。

4. 利用上面获取的物理块号拼接页内地址形成物理地址，使用该地址访存。


## 页框分配

### 驻留集大小

### 内存分配策略

### 物理块调入算法

### 调入页面的时机

### 从何处调入页面

## 页面置换算法

### 最佳置换算法

### 先进先出置换算法

### 最近最久未使用置换算法

### 最近未使用置换算法

### 时钟置换算法

## 抖动和工作集

### 抖动

### 工作集

## 页框回收

### 页面缓冲算法


[^1]: 《2026年操作系统考研复习指导》（王道论坛[编著]）P214