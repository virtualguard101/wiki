---
date: 2025-10-31 14:15:36
title: 内存管理概述
permalink: 
publish: true
---

# 内存管理概述

## 内存管理主要功能

- 内存空间的分配与回收

- 地址转换

- 内存空间的扩充

- 内存共享

- 存储保护

## 内存管理基本概念

### 逻辑地址与物理地址

- 逻辑地址

    程序编译后，各个模块都从 0 开始编址，这个地址称为该模块的**逻辑地址**，也称为**相对地址**。针对x86系统，逻辑地址范围为 $0 \sim 2^{32} - 1$，即 $0 \sim 4GB$。进程在运行过程中，其本身看到与使用的内存地址就是逻辑地址。

- 物理地址

    内存中物理单元的集合，地址转换的最终结果。CPU在运行程序时，执行指令和访问数据，最后都要通过物理地址从主存中存取。

操作系统通过[**内存管理部件（*MMU*）**](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83)将进程使用的逻辑地址转换为物理地址。

### 程序的链接与装入

创建一个进程需要先将一个程序和运行所需的数据装入内存中。将用户源程序转变为可在内存中执行的程序，需要经过以下几个步骤：

![](assets/3-memory-management/link_load.png)

- 编译: 由编译程序将源代码编译成若干个目标模块

- 链接: 由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块

    当链接程序将各个模块链接成一个完整的可执行程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的**逻辑地址空间**。

- 装入: 由装入程序将装入模块装入内存运行

    当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换为物理地址，这个过程称为**地址重定位**。

### 链接方式

- 静态链接

    在程序运行前，先将各个目标模块及它们所需的库函数链接成一个完整的装入模块，以后不再拆开的连接方式。

    ![](assets/3-memory-management/static_link.png)

    将几个目标模块装配成一个装入模块，需要解决两个问题:

    - **修改相对地址**: 每个目标模块的相对地址都是从0开始的

    - **变换外部调用符号**: 将每个模块中所用的外部调用符号也都变换为相对地址

- 装入时动态链接

    将编译后的一组模块装入内存时，采用**边装入边链接**的链接方式。

- 运行时动态链接

    在程序执行中需要访问到目标模块时，才对目标模块进行链接。

### 装入方式


- 绝对装入

    ![](assets/3-memory-management/absolute_loader.png)

    该方式仅适用于单道程序环境。程序中的逻辑地址与物理地址完全一致，不需要进行地址转换。

- 可重定位装入（静态重定位）

    ![](assets/3-memory-management/relocatable_loading.png)

    该方式可用于多道程序环境。由于在装入时会发生地址转换，因此程序可以装入主存的任何位置。

    但是，这种装入方式是**一次完成**的。当一个作业装入内存时，必须分配其要求分配的所有空间；作业一旦进入内存，在运行期间就不能再移动，也不能再申请内存空间。

- 动态运行时装入（动态重定位）

    ![](assets/3-memory-management/dynamic_loading.jpg)

    该方式允许一个作业在内存中移动，从而便于实现**可重入**。使用该方式装入时，不会立即将相对地址转换为绝对地址，最终的物理地址在**程序运行时**才会确定。

??? tip "静态可重定位 vs 动态可重定位[^1]"
    - 在静态重定位中，地址转换发生在装载时：当程序装载到内存中时，store指令对应的地址已经转变成了物理地址

    ![](assets/3-memory-management/relocatable.png)

    - 在动态重定位中，地址转换发生在运行时：当程序装载到内存中时，store指令对应的地址仍然是逻辑地址，当真正运行该条指令时，会通过硬件MMU（内存管理单元）将逻辑地址转换为物理地址

    ![](assets/3-memory-management/dynamic.png)

    在后者中，实现地址转换的硬件设施就是[前面](#逻辑地址与物理地址)提到的**MMU**。

### 进程的内存映像


![](assets/3-memory-management/user_mem.jpg)

上图主要展示的是一个进程内存映像的**用户空间**，一般包括以下要素:

- 代码段 (*text*): 程序的二进制代码。代码段是只读的，可被多个进程共享

- 数据段 (*data*): 程序运行时加工处理的对象，包括全局变量与静态变量

- 堆 (*heap*): 动态分配的内存空间，用于存储程序运行时动态分配的变量

- 栈 (*stack*): 用来实现函数调用与局部变量的存储

完整的进程地址空间与内核地址空间的结构可以参考下图[^2]:

![](assets/3-memory-management/process-address.png)

内核空间通常对用户是不可见的。在学习进程时提到的[进程控制块 (PBC)](2-process.md#进程控制块)就是存储在内核空间中。

### 内存保护

- 设置一对**上、下限寄存器**，存放进程的上下限地址，**用于检查访问地址是否越界**

- 采用**基址寄存器（重定位寄存器）**与**限长寄存器（界地址寄存器）**进行越界检查

    - 重定位寄存器: 存放进程的起始地址

    - 界地址寄存器: 存放进程的最大逻辑地址

    二者的区别在于前者用于“加”，逻辑地址“加”上重定位寄存器得到物理地址；后者用于“比”，通过比较界地址寄存器与逻辑地址的值判断是否越界

### 内存共享

### 内存分配与回收

## 连续分配管理方式

顾名思义，连续分配的管理方式就是在内存空间中为用户程序分配一个连续的内存空间。

### 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**两部分。系统区通常位于低地址部分，用于存放操作系统内核，仅供操作系统使用；用户区位于高地址部分，仅存放一道用户程序，即用户程序**独占**整个用户空间。

这种方式的优点是简单、无外部碎片，不需要进行内存保护；缺点也很明显，只能用于单用户、单任务系统，且会产生内部碎片，**内存利用率极低**。

### 固定分区分配

固定分区分配将用户空间划分为若干个固定大小的分区，每个分区只装入一个作业，是最简单的一种多道程序存储管理方式。

### 动态分区分配



[^1]: [内存管理 | KingOfDark](https://2017zhangyuxuan.github.io/2022/06/11/2022-06/2022-06-11%20%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5)

[^2]: [Linux 内存分析——进程和物理结构角度 | Tomoku's blog](https://tomoku-dm.github.io/2019/04/13/1-memory-process-physical/)