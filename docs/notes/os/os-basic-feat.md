---
date: 2025-10-20 09:03:45
title: 操作系统基本特性
permalink: 
publish: true
---

# 操作系统基本特性

## 并发

### 定义

**并发（*Concurrency*）**：指**在同一时间间隔**内，多个程序在单个CPU上交替执行，造成一种“同时”运行的假象。

!!! tip "并行"
    与并发相似的一个概念是**并行**。并行指的是多个事件**在同一时刻发生**。

### 引入进程

#### 为什么需要引入进程

在未引入进程的系统中，属于同一程序的**I/O操作**与**计算操作**是串行的，即二者只能**顺序执行**。

但在引入进程后，可以将二者都**抽象成进程**（~~根据答案推过程这一块~~），从而实现**并发**。对多个不同的程序也同理。这样就能极大地增加系统的吞吐量，从而提升系统资源的利用率。

在Linux上，可通过 [`htop`](../tools/linux/htop.md) 工具查看系统中各个进程的基本信息与运行状态。

#### 什么是进程

所谓[进程](process.md)，就是指在系统中能独立运行并作为资源分配的基本单位，是一个**动态的**活动**实例**。

基于面向对象的思想，可以将程序理解为一个**类**，而进程则是该类的一个**实例**。

## 共享

### 操作系统视角下的共享

普通语境下的共享与操作系统视角下的共享在含义上并不完全相同。

- 针对前者，试想学校中的共享打印机，就算是在使用高峰期，但也只需适当的安排（先来先打印，即排队即可），用户基本就不会产生对该共享资源的竞争（有不守规矩的除外），并不需要对资源使用者应该如何使用资源做出限制。

- 而针对后者，也称为**资源复用**。宏观上，

    - 系统中的资源远少于多道程序需求的总和，不加以限制极易引发它们对共享资源的争夺；

    - 共享资源本身存在不同属性，不同进程对资源复用的方式也不同；

    - ==共享资源的使用对象是**计算机程序（进程）**，不是人==，得详细规定它们对资源的访问权限与使用方式。

### 实现共享的方式

#### 互斥共享

同一时间间隔内**只允许一个进程访问**该资源，这种方式称为**互斥共享**。

只有资源空闲，或是原先占有该资源的进程释放资源后，其他进程才能对该资源进行访问，否则必须等待，访问形式类似“进程的串行执行”。这种资源被称为**临界资源**。

系统中大多数**物理设备**、以及**栈**、**变量**、**表格**等都属于临界资源。

#### 同时共享

同一时间间隔内允许**多个进程“同时”访问**该资源，这种方式称为**同时共享**。

宏观上，多个进程“同时”访问临界资源，但**微观上**，这些进程是交替执行的。

典型的同时共享资源有**磁盘**、**文件**等，拿后者举例，一些可重用的代码（如库函数）就是同时共享资源，可被多个进程“同时”访问。

## 虚拟

在操作系统中，==使用某种技术将一个物理实体映射为若干个逻辑实体==，从而实现对物理实体的复用，这种方式称为**虚拟**。

早期的虚拟化技术起源于通信领域，如电话系统中的信道复用技术，即将一条物理信道划分为多个逻辑信道，每个逻辑信道可以被多个用户“同时”使用。

虚拟化通常通过**时分复用**和**空分复用**两种方式实现。

### 时分复用

简单来说，**时分复用（*Time Division Multiplexing, TDM*）**就是将时间分割成小段，多个进程轮流使用CPU时间片，实现资源的时间共享。

可以结合一段简化的 Python 代码理解:
```py
# 简化的时间片轮转示例
def round_robin_scheduler(processes, time_slice=5):
    while processes:
        current_process = processes.pop(0)
        print(f"执行进程 {current_process}，时间片：{time_slice}ms")
        
        if not current_process.is_completed():
            processes.append(current_process)  # 未完成则重新排队
```

### 空分复用

与时分复用类似，**空分复用（*Space Division Multiplexing, SDM*）**就是将物理存储空间分割成多个逻辑空间，让多个进程可以"同时"使用不同的内存区域。

```py
# 虚拟内存管理示例
class VirtualMemory:
    def __init__(self, total_memory):
        self.total_memory = total_memory
        self.allocated_memory = {}
    
    def allocate_process_memory(self, process_id, size):
        # 为进程分配虚拟内存空间
        self.allocated_memory[process_id] = size
        print(f"进程 {process_id} 分配了 {size}MB 虚拟内存")
```

## 异步

**异步（*Asynchronous*）**是指进程的执行不需要等待前一个操作完全完成，即可启动新操作并继续执行其他任务，从而达到可以同时进行多个操作的效果，提高系统效率。

异步有三个重要原则:

- **非阻塞执行**：不等待操作完成就继续执行其他操作；

- **事件驱动**：通过事件通知机制处理完成的操作；

- **并发处理**：多个操作可以同时进行；


```py
# 异步操作示例
import asyncio

async def async_io_operation():
    print("开始I/O操作...")
    await asyncio.sleep(2)  # 模拟I/O等待
    print("I/O操作完成")
    return "结果"

async def main():
    # 同时启动多个异步操作
    tasks = [async_io_operation() for _ in range(3)]
    results = await asyncio.gather(*tasks)
    print(f"所有操作完成: {results}")
```
