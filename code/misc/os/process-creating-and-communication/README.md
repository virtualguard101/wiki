# 进程创建与通信

本目录包含了几个关于进程创建和进程间通信的C语言示例程序。这些示例演示了Linux/Unix系统中进程管理的基本概念和操作。

## getProcess.c

### 功能概述
该程序演示了`fork()`的基本用法以及如何获取**进程ID（PID）**和**父进程ID（PPID）**。

### 核心概念
- **fork()返回值**：
  - 在子进程中返回0
  - 在父进程中返回子进程的PID
  - 失败返回-1
- **getpid()**：获取当前进程的PID
- **getppid()**：获取父进程的PID

### 代码流程
1. **第一次fork**（第7行）
   - 创建第一个子进程
   - 此时有两个进程：原始父进程和第一个子进程

2. **第二次fork**（第8行）
   - ⚠️ **重要**：两个进程都会执行这行代码
   - 原始父进程fork出第二个子进程
   - 第一个子进程也会fork出它的子进程
   - 最终会有4个进程！

3. **子进程处理**（第10-14行）
   - 打印自己的PID和父进程的PPID
   - 退出

4. **父进程处理**（第15-20行）
   - 打印自己的PID和子进程的PID
   - 睡眠1秒后退出

### 进程树结构
```
原始进程 (P1)
├── 子进程1 (C1)
│   └── 子进程1的子进程 (C1-1)
└── 子进程2 (C2)
```

### 潜在问题
⚠️ **注意**：由于调用了两次`fork()`，会创建多个进程，但代码逻辑可能不符合预期：
- `childpid`变量在第二次fork后会被覆盖
- 第一个子进程的PID信息会丢失
- 建议只调用一次`fork()`，或者使用不同的变量存储每次fork的返回值

### 改进建议
- 如果只需要一个子进程，删除第二次`fork()`
- 如果需要多个子进程，使用循环和数组管理PID

---

## processArray.c

### 功能概述
该程序演示了**父子进程协作处理数组**的场景，通过任务分割来提高处理效率。

### 核心概念
- **任务分割**：将大任务（计算100个数的和）分割给父子进程分别处理
- **进程间数据独立性**：每个进程有独立的变量副本

### 代码流程
1. **数组初始化**（第8-10行）
   - 创建包含100个元素的数组，值为1到100

2. **创建子进程**（第11行）
   - 使用`fork()`创建子进程

3. **子进程处理**（第12-17行）
   - 计算数组前50个元素（索引0-49）的和
   - 打印子进程的计算结果

4. **父进程处理**（第18-24行）
   - 计算数组后50个元素（索引50-99）的和
   - 打印父进程的计算结果

### 关键要点
- 父子进程共享代码段，但拥有独立的数据段
- 每个进程的`sum`变量是独立的，互不影响
- 这是一种简单的并行计算模式

### 注意事项
⚠️ 该程序没有使用进程间通信机制，所以：
- 无法将两个部分的和合并
- 如果需要最终结果，需要使用管道、共享内存或其他IPC机制

---

## multi-processes.c

### 功能概述
该程序演示了如何创建**多个子进程**，每个子进程执行相同的任务（模拟石头剪刀布游戏）。

### 核心概念
- **多次fork**：通过循环调用`fork()`创建多个子进程
- **进程独立性**：每个子进程都有独立的地址空间和随机数种子

### 代码流程
1. **playGame函数**（第7-22行）
   - 使用进程ID和时间作为随机数种子，确保每个进程的随机性
   - 生成1-3之间的随机数，分别对应石头、布、剪刀
   - 打印对应的选择并返回

2. **主函数**（第24-37行）
   - 循环5次（i从1到5）
   - 每次循环调用`fork()`创建一个子进程
   - 子进程执行`playGame()`后立即退出
   - 父进程继续循环，创建下一个子进程

### 潜在问题
⚠️ **注意**：该程序存在一个问题 - 父进程没有使用`wait()`等待子进程结束，可能导致：
- 子进程变成僵尸进程
- 程序输出顺序不确定
- 父进程可能在子进程完成前就退出

### 改进建议
- 在循环中使用`wait()`或`waitpid()`等待每个子进程
- 或者使用进程数组存储子进程PID，最后统一等待

---

## pipe.c

### 功能概述
该程序演示了父子进程之间使用**管道（pipe）**进行进程间通信（IPC）的基本方法。

### 核心概念
- **管道（pipe）**：一种半双工的通信机制，允许数据在一个方向上流动
- **pipe_fd[2]**：管道文件描述符数组，`pipe_fd[0]`用于读，`pipe_fd[1]`用于写

### 代码流程
1. **创建管道**（第12-16行）
   - 使用`pipe(pipe_fd)`创建管道，必须在`fork()`之前创建
   - 如果创建失败，程序退出

2. **创建子进程**（第17-21行）
   - 使用`fork()`创建子进程
   - 检查fork是否成功

3. **子进程处理**（第23-32行）
   - 关闭写端`pipe_fd[1]`（因为子进程只需要读取）
   - 从管道读取数据到缓冲区
   - 打印接收到的消息
   - 关闭读端并退出

4. **父进程处理**（第33-41行）
   - 关闭读端`pipe_fd[0]`（因为父进程只需要写入）
   - 向管道写入消息"Hello from parent process!"
   - 关闭写端
   - 使用`wait(NULL)`等待子进程结束

### 关键要点
- 管道必须在fork之前创建，这样子进程才能继承文件描述符
- 每个进程都应该关闭不需要的文件描述符端，避免资源泄漏
- 父进程使用`wait()`确保子进程完成后再继续

---

## rps.c

### 功能概述
该程序演示了父子进程之间使用**管道进行数据传递**的实际应用场景：实现一个**石头剪刀布游戏**。父进程（Dad）和子进程（Child）各自生成选择，通过管道传递父进程的选择，子进程接收后进行游戏判断并输出结果。

### 核心概念
- **管道通信**：父进程通过管道将选择（整数）发送给子进程
- **进程间数据传递**：使用`write()`和`read()`系统调用传递整型数据
- **游戏逻辑**：实现石头剪刀布的基本规则判断

### 代码流程
1. **generateChoice函数**（第10-13行）
   - 使用当前时间和进程ID作为随机数种子，确保每个进程的随机性
   - 生成1-3之间的随机数，分别对应：1=Rock（石头）、2=Paper（布）、3=Scissors（剪刀）

2. **choiceToString函数**（第16-23行）
   - 将数字选择转换为可读的字符串
   - 用于输出显示

3. **playGame函数**（第26-41行）
   - 判断游戏结果
   - 返回1表示父进程赢，-1表示子进程赢，0表示平局
   - 实现规则：石头>剪刀，布>石头，剪刀>布

4. **主函数 - 创建管道**（第49-53行）
   - 使用`pipe(pipefd)`创建管道，必须在`fork()`之前创建

5. **主函数 - 创建子进程**（第55-61行）
   - 使用`fork()`创建子进程
   - 检查fork是否成功

6. **父进程处理**（第63-79行）
   - 关闭读端`pipefd[0]`（父进程只需要写入）
   - 生成父进程的选择（第68行）
   - 将选择（整数）写入管道（第71-74行）
   - 关闭写端
   - 使用`wait(NULL)`等待子进程完成

7. **子进程处理**（第80-109行）
   - 关闭写端`pipefd[1]`（子进程只需要读取）
   - 从管道读取父进程的选择（第85-88行）
   - 关闭读端
   - 生成子进程自己的选择（第93行）
   - 输出双方的选择和游戏结果（第96-107行）
   - 退出

### 关键要点
- **数据传递**：使用`sizeof(int)`确保传递完整的整数数据
- **随机数种子**：使用`time(NULL) ^ getpid()`确保父子进程的随机数种子不同
- **单向通信**：父进程只发送数据，子进程只接收数据，符合管道的半双工特性
- **进程同步**：父进程使用`wait()`确保子进程完成输出后再退出

### 游戏规则
- **Rock (1)** 击败 **Scissors (3)**
- **Paper (2)** 击败 **Rock (1)**
- **Scissors (3)** 击败 **Paper (2)**
- 相同选择则为平局

### 注意事项
- 该程序演示了管道在实际应用中的使用，比`pipe.c`更复杂
- 子进程负责所有输出，父进程只负责生成和发送选择
- 使用`exit(0)`确保子进程正确退出

---

## 总结

这些示例程序涵盖了进程管理的基本操作：

1. **进程创建**：使用`fork()`系统调用
2. **进程通信**：使用管道进行父子进程间通信
3. **进程协作**：通过任务分割实现并行处理
4. **进程信息**：获取进程ID和父进程ID

### 编译和运行
```bash
# 编译所有程序
gcc pipe.c -o pipe
gcc multi-processes.c -o multi-processes
gcc processArray.c -o processArray
gcc getProcess.c -o getProcess
gcc rps.c -o rps

# 运行示例
./pipe
./multi-processes
./processArray
./getProcess
./rps
```

### 学习要点
- 理解`fork()`的工作原理和返回值
- 掌握管道的基本使用方法
- 注意进程间的资源管理和同步
- 避免僵尸进程的产生
